let hCatch = \ prog ->
  handle {
  | throw p k -> Nothing
  | catch m1 m2 p k -> k p {
      match (hCatch m1)! {
      | Nothing -> m2!
      | Just x -> x
      }
    }
  | return x _ -> x
  } Z prog! in
let hState = \ s0 -> \ prog ->
  handle {
  | get    s k -> k s { s }
  | put s' s k -> k s' { Z }
  | return x s -> x
  } s0 prog! in
let transact = {
  let _ = (`put (S Z)) in
  let _ = (`catch { let _ = (`put (S (S Z))) in `throw } { Z }) in
  `get
} in
Pair (hCatch (hState Z transact))!
     (hState Z (hCatch transact))!

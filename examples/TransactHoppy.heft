let hCatch = \ prog ->
  handle {
  | throw p k -> { Nothing }
  | catch m1 m2 p k -> k p {
      match (hCatch m1)! {
      | Nothing -> m2!
      | Just x -> x
      }
    }
  | return x _ -> { Just x }
  } Z prog! in
let hCatch2 = \ prog ->
  handle {
  | throw p k -> { Nothing }
  | catch m1 m2 p k -> k p {
      match (hCatch2 m1)! {
      | Nothing -> `abort { k p m2 }
      | Just x -> x
      }
    }
  | abort m p k -> m
  | return x _ -> { Just x }
  } Z prog! in
let hState = \ s0 -> \ prog ->
  handle {
  | get    s k -> k s { s }
  | put s' s k -> k s' { Z }
  | return x s -> { Pair x s }
  } s0 prog! in
let transact = {
  let _ = `put (S Z) in
  let _ = `catch { let _ = `put (S (S Z)) in `throw } { Z } in
  `get
} in
Tuple (hCatch (hState Z transact))!
      (hState Z (hCatch transact))!
      (hCatch2 (hState Z transact))! -- interaction!
      (hState Z (hCatch2 transact))!

data S0
| Done
| Fail
| Test S0
| Neg S0
| Seq S0 S0
| Or S0 S0
| OrL S0 S0
| Rec String S0
| SVar String

data Term
| TVar String
| Con String (List Term)

data Env (v : *) (e : R)
| ENil
| ECons Var (List Var) { v / e * e } (Env v e)

data Unit
| U

data List (a : *)
| Nil (List a)
| Cons a (List a)

-- non deterministic sequential programs
effect S0 -- (v : *)
| fail    : { a / <S0, e> * eg }
| negate  : { a / <S0, e> * eg } -> { a / <S0, e> * eg }
| test    : { a / <S0, e> * eg } -> { a / <S0, e> * eg }
| choose  : { a / <S0, e> * eg } -> { a / <S0, e> * eg } -> { a / <S0, e> * eg }
| chooseL : { a / <S0, e> * eg } -> { a / <S0, e> * eg } -> { a / <S0, e> * eg }
-- can also be used as variable if applied to zero arguments:
| app     : Var -> List { v / <S0, e> * eg } -> { v / <S0, e> * eg }
| recurse : Var -> { a / <S0, e> * eg } -> { a / <S0, e> * eg }

effect Prog -- (ei : Row) (v : *)
| define  : Var -> List Var -> { v / ei * ei } -> { Unit / <Prog, e> * eg }

val append -- : List a -> List a -> List a
  = \xs -> \ys -> match xs
                  | Nil -> ys
                  | Cons x' xs' -> Cons x' (append xs' ys)
                  end

val lookupEnv -- : Var -> Env e -> Maybe (Tuple (List Var) { Term / e * e })
  = \x -> \env ->
    match env
    | ECons y args m ys ->
      match (x == y)
      | True -> Just (Tuple args m)
      | False -> lookupEnv x ys
      end
    end

val growEnv -- : List String -> List { v / e * e } -> Env e -> Env e
  = \xs -> \ys -> \env ->
    match xs
    | Nil -> env
    | Cons x xs' ->
      match ys
      | Cons y ys' -> ECons x Nil y (growEnv xs' ys' env)
      end
    end

val hS0 -- : Env -> Term -> { a / <S0, e> * eg } -> { List Term / e * eg }
  = \env0 -> \t0 -> \m0 -> {
    handle S0
    | fail _ k -> Nil
    | negate m _ k -> (k U { match (hS0 env0 t0 m)!
                             | Nil -> Cons t0 Nil
                             | Cons _ _ -> Nil
                             end })!
    | test m _ k -> (k U { match (hS0 env0 t0 m)!
                           | Nil -> Nil
                           | Cons _ _ -> Cons t0 Nil
                           end })!
    | choose m1 m2 _ k -> (k U { append ((hS0 env0 t0 m1)!) ((hS0 env0 t0 m2)!) })!
    | chooseL m1 m2 _ k -> (k U { match (hS0 env0 t0 m1)!
                                  | Nil -> (hS0 env0 t0 m2)!
                                  | Cons x xs -> Cons x xs
                                  end })!
    | app f xs _ k -> match lookupEnv f env0
                      | Just (Tuple xs' m) -> (k U (hS0 (growEnv xs' xs env0) t0 m))!
                      | Nothing -> Nil
                      end
    -- is this still denotational?
    | recurse n m _ k -> (k U { hS0 (ECons n { `recurse m } env0) t0 m })!
    | return _ _ -> Cons t0 Nil
    end U m0!
}

val hS0' = hS0 ENil (TCons X Nil)

--------------------------------------------------------------------------------
-- fail
--------------------------------------------------------------------------------

val test_fail_prog0 = { `fail }
val test_fail0 = {
  match (hS0' test_fail_prog0)!
  | Nil -> T
  | Cons _ _ -> F
  end
}

--------------------------------------------------------------------------------
-- negate
--------------------------------------------------------------------------------

-- negate a failure
val test_negate_prog0 = { `negate { `fail } }
val test_negate0 = {
  match (hS0' test_negate_prog0)!
  | Nil -> F
  | Cons _ xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

-- negate a success
val test_negate_prog1 = { `negate { A } }
val test_negate1 = {
  match (hS0' test_negate_prog1)!
  | Nil -> T
  | Cons _ _ -> F
  end
}

--------------------------------------------------------------------------------
-- test
--------------------------------------------------------------------------------

-- this test currently doesn't do much because there are no functions yet that modify the term 
val test_test_prog0 = { `test { A } }
val test_test0 = {
  match (hS0' test_test_prog0)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

--------------------------------------------------------------------------------
-- choose
--------------------------------------------------------------------------------

val test_choose_prog0 = { `choose {A} {B} }
val test_choose0 = {
  match (hS0' test_choose_prog0)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> F
    | Cons y ys ->
      match ys
      | Nil -> T
      | Cons _ _ -> F
      end
    end
  end
}

val test_choose_prog1 = { `choose {`fail} {B} }
val test_choose1 = {
  match (hS0' test_choose_prog1)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

val test_choose_prog2 = { `choose {A} {`fail} }
val test_choose2 = {
  match (hS0' test_choose_prog2)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

val test_choose_prog3 = { `choose {`fail} {`fail} }
val test_choose3 = {
  match (hS0' test_choose_prog3)!
  | Nil -> T
  | Cons _ _ -> F
  end
}

--------------------------------------------------------------------------------
-- chooseL
--------------------------------------------------------------------------------

val test_chooseL_prog0 = { `choose {A} {B} }
val test_chooseL0 = {
  match (hS0' test_chooseL_prog0)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

val test_chooseL_prog1 = { `chooseL {`fail} {B} }
val test_chooseL1 = {
  match (hS0' test_chooseL_prog1)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

val test_chooseL_prog2 = { `chooseL {A} {`fail} }
val test_chooseL2 = {
  match (hS0' test_chooseL_prog2)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

val test_chooseL_prog3 = { `chooseL {`fail} {`fail} }
val test_chooseL3 = {
  match (hS0' test_chooseL_prog3)!
  | Nil -> T
  | Cons _ _ -> F
  end
}

--------------------------------------------------------------------------------
-- app
--------------------------------------------------------------------------------

val test_app_prog0 = { `app Id (Cons {A} Nil) }
val test_app0 = {
  match (hS0 (ECons Id (Cons Y Nil) { `app Y Nil } ENil) (TCons X Nil) test_app_prog0)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

--------------------------------------------------------------------------------
-- recurse
--------------------------------------------------------------------------------

val test_recurse_prog0 = { `recurse Y { `chooseL { A } { `app Y Nil } } }
val test_recurse0 = {
  match (hS0' test_recurse_prog0)!
  | Nil -> F
  | Cons x xs ->
    match xs
    | Nil -> T
    | Cons _ _ -> F
    end
  end
}

val main = {
  Tuple
    (test_fail0)!
    (test_negate0)!
    (test_negate1)!  -- F
    (test_test0)!
    (test_choose0)!  -- F
    (test_choose1)!
    (test_choose2)!
    (test_choose3)!  -- F
    (test_chooseL0)!
    (test_chooseL1)!
    (test_chooseL2)!
    (test_chooseL3)! -- F
    (test_app0)!
    (test_recurse0)!
}
